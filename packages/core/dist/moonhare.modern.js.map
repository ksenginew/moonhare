{"version":3,"file":"moonhare.modern.js","sources":["../src/order.ts","../src/parse.ts","../src/setup.ts","../src/index.ts"],"sourcesContent":["let selectorOrder = ['^:h', '^:f', '^:a']\nlet atRuleOrder = ['^@media']\n\nlet getSelectorScore = (selector: string, selOrder: (string | RegExp)[]) => {\n    let score = 0\n    selOrder.forEach((o, i) => {\n        if (selector.match(o)) score += i + 1\n    })\n    return score\n}\n\nlet getAtRuleScore = (atRules: string[], atOrder: (string | RegExp)[]) => {\n    let score = 0\n    atRules.forEach((atRule, ii) => {\n        atOrder.forEach((o, i) => {\n            if (atRule && atRule.match(o)) score += (i + 1) * (ii + 1)\n        })\n    })\n    return score\n}\n\nexport { getSelectorScore, getAtRuleScore, selectorOrder, atRuleOrder }\n","import { CSSAttribute, Style } from './types'\n\n/**\n * parses the object into css, scoped, blocks\n * @param {Object} obj\n * @param {String} selector\n * @param {String} wrapper\n */\nexport let parse = (obj: CSSAttribute, selector = '{:}') => {\n    let styles: Style[] = []\n\n    for (let key in obj) {\n        let val = obj[key]\n\n        let decl = (val?: string | number) => {\n            // If this isn't an empty rule\n            if (val != undefined) key = key.replace(/[A-Z]/g, '-$&').toLowerCase()\n            // Push the line for this property\n            styles.push({\n                s: selector,\n                p: key,\n                v: val + '',\n                a: []\n            })\n        }\n        if (Array.isArray(val)) {\n            val.map(decl)\n        } else if (key[0] == '@') {\n            // Regular at rule block\n            parse(val as CSSAttribute, key[1] == 'k' ? '' : selector).forEach((style) => {\n                style.a.push(key)\n                styles.push(style)\n            })\n        } else if (typeof val == 'object') {\n            val\n            // Call the parse for this block\n            let newSel = selector\n                ? // Go over the selector and replace the matching multiple selectors if any\n                  selector.replace(/([^,])+/g, (sel) => {\n                      // Return the current selector with the key matching multiple selectors if any\n                      return key.replace(/(^:.*)|([^,])+/g, (k) => {\n                          // If the current `k`(key) has a nested selector replace it\n                          if (/&/.test(k)) return k.replace(/&/g, sel)\n\n                          // If there's a current selector concat it\n                          return sel ? sel + ' ' + k : k\n                      })\n                  })\n                : key\n            styles = styles.concat(parse(val, newSel))\n        } else {\n            decl(val)\n        }\n    }\n\n    // If we have properties apply standard rule composition\n    return styles\n}\n","import { CSSAttribute, Style } from './types'\nimport { atRuleOrder, getAtRuleScore, getSelectorScore, selectorOrder } from '../../core/src/order'\nimport { parse } from './parse'\n\nexport let setup = (\n    selOrder: (string | RegExp)[] = selectorOrder,\n    atOrder: (string | RegExp)[] = atRuleOrder\n) => {\n    // count to generate unique class names.\n    let count: number = 0\n\n    // JavaScript Map like implementation for style sheet.\n    let sheet: Style[] = []\n    let cache: string[] = []\n\n    let render = (styles: CSSAttribute) => {\n        return parse(styles)\n            .map((style) => {\n                //\n                let { s: selector, p: property, v: value, a: atRules } = style\n                let ref = selector + property + value + atRules\n\n                // check the cache for the style\n                let index = cache.indexOf(ref)\n\n                // if the style is not in the cache\n                if (!~index) {\n                    // generate a unique class name. It's base 36 number\n                    let className = (style.c = '_' + (count++).toString(36))\n\n                    // give marks to atRules\n                    let atRuleScore = (style.r = getAtRuleScore(atRules, atOrder))\n                    // give marks to selector\n                    let score = (style.r = getSelectorScore(\n                        selector.replace(/^\\{:\\}/, ''),\n                        selOrder\n                    ))\n\n                    // set the index to last\n                    index = sheet.length\n\n                    // find the index of the style\n                    for (let i = 0, len = sheet.length; i < len; ++i) {\n                        if (\n                            (sheet[i].r as number) > atRuleScore ||\n                            (sheet[i].m as number) > score\n                        ) {\n                            index = i\n                            break\n                        }\n                    }\n\n                    // insert the class name to the selector\n                    style.s = selector.replace(/{:}/g, '.' + className)\n\n                    // update the sheet\n                    sheet.splice(index, 0, style)\n                    cache.splice(index, 0, ref)\n                }\n\n                // return the class name\n                return sheet[index].c as string\n            })\n            .join(' ')\n    }\n\n    return { render, sheet }\n}\n","import { setup } from './setup'\n\nlet { render, sheet } = setup()\n\nexport { render, sheet, setup }\n\nexport type { Style, Context, CSSAttribute } from './types'\n"],"names":["selectorOrder","atRuleOrder","parse","obj","selector","styles","key","val","decl","undefined","replace","toLowerCase","push","s","p","v","a","Array","isArray","map","forEach","style","newSel","sel","k","test","concat","setup","selOrder","atOrder","count","sheet","cache","render","property","value","atRules","ref","index","indexOf","className","c","toString","atRuleScore","r","score","atRule","ii","o","i","match","getAtRuleScore","getSelectorScore","length","len","m","splice","join"],"mappings":"AAAA,IAAIA,EAAgB,CAAC,MAAO,MAAO,OAC/BC,EAAc,CAAC,WCORC,EAAQ,CAACC,EAAmBC,EAAW,SAC9C,IAAIC,EAAkB,GAEtB,IAAK,IAAIC,KAAOH,EAAK,CACjB,IAAII,EAAMJ,EAAIG,GAEVE,EAAQD,IAEGE,MAAPF,IAAkBD,EAAMA,EAAII,QAAQ,SAAU,OAAOC,eAEzDN,EAAOO,KAAK,CACRC,EAAGT,EACHU,EAAGR,EACHS,EAAGR,EAAM,GACTS,EAAG,MAGX,GAAIC,MAAMC,QAAQX,GACdA,EAAIY,IAAIX,WACS,KAAVF,EAAI,GAEXJ,EAAMK,EAA+B,KAAVD,EAAI,GAAY,GAAKF,GAAUgB,QAASC,IAC/DA,EAAML,EAAEJ,KAAKN,GACbD,EAAOO,KAAKS,aAEK,iBAAPd,EAAiB,CAG/B,IAAIe,EAASlB,EAEPA,EAASM,QAAQ,WAAaa,GAEnBjB,EAAII,QAAQ,kBAAoBc,GAE/B,IAAIC,KAAKD,GAAWA,EAAEd,QAAQ,KAAMa,GAGjCA,EAAMA,EAAM,IAAMC,EAAIA,IAGrClB,EACND,EAASA,EAAOqB,OAAOxB,EAAMK,EAAKe,SAElCd,EAAKD,GAKb,OAAOF,GCpDAsB,EAAQ,CACfC,EAAgC5B,EAChC6B,EAA+B5B,KAG/B,IAAI6B,EAAgB,EAGhBC,EAAiB,GACjBC,EAAkB,GAqDtB,MAAO,CAAEC,OAnDK5B,GACHH,EAAMG,GACRc,IAAKE,IAEF,IAAMR,EAAGT,EAAUU,EAAGoB,EAAUnB,EAAGoB,EAAOnB,EAAGoB,GAAYf,EACrDgB,EAAMjC,EAAW8B,EAAWC,EAAQC,EAGpCE,EAAQN,EAAMO,QAAQF,GAG1B,KAAMC,EAAO,CAET,IAAIE,EAAanB,EAAMoB,EAAI,KAAOX,KAASY,SAAS,IAGhDC,EAAetB,EAAMuB,EFpBxB,EAACR,EAAmBP,KACrC,IAAIgB,EAAQ,EAMZ,OALAT,EAAQhB,QAAQ,CAAC0B,EAAQC,KACrBlB,EAAQT,QAAQ,CAAC4B,EAAGC,KACZH,GAAUA,EAAOI,MAAMF,KAAIH,IAAUI,EAAI,IAAMF,EAAK,QAGzDF,GEasCM,CAAef,EAASP,GAEjDgB,EAASxB,EAAMuB,EF9BhB,EAACxC,EAAkBwB,KACtC,IAAIiB,EAAQ,EAIZ,OAHAjB,EAASR,QAAQ,CAAC4B,EAAGC,KACb7C,EAAS8C,MAAMF,KAAIH,GAASI,EAAI,KAEjCJ,GEyBgCO,CACnBhD,EAASM,QAAQ,SAAU,IAC3BkB,GAIJU,EAAQP,EAAMsB,OAGd,IAAK,IAAIJ,EAAI,EAAGK,EAAMvB,EAAMsB,OAAQJ,EAAIK,IAAOL,EAC3C,GACKlB,EAAMkB,GAAGL,EAAeD,GACxBZ,EAAMkB,GAAGM,EAAeV,EAC3B,CACEP,EAAQW,EACR,MAKR5B,EAAMR,EAAIT,EAASM,QAAQ,OAAQ,IAAM8B,GAGzCT,EAAMyB,OAAOlB,EAAO,EAAGjB,GACvBW,EAAMwB,OAAOlB,EAAO,EAAGD,GAI3B,OAAON,EAAMO,GAAOG,IAEvBgB,KAAK,KAGG1B,MAAAA,KChEjBE,OAAEA,EAAFF,MAAUA,GAAUJ"}