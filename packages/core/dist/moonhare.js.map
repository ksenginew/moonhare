{"version":3,"file":"moonhare.js","sources":["../src/order.ts","../src/parse.ts","../src/setup.ts","../src/index.ts"],"sourcesContent":["let selectorOrder = ['^:h', '^:f', '^:a']\nlet atRuleOrder = ['^@media']\n\nlet getSelectorScore = (selector: string, selOrder: (string | RegExp)[]) => {\n    let score = 0\n    selOrder.forEach((o, i) => {\n        if (selector.match(o)) score += i + 1\n    })\n    return score\n}\n\nlet getAtRuleScore = (atRules: string[], atOrder: (string | RegExp)[]) => {\n    let score = 0\n    atRules.forEach((atRule, ii) => {\n        atOrder.forEach((o, i) => {\n            if (atRule && atRule.match(o)) score += (i + 1) * (ii + 1)\n        })\n    })\n    return score\n}\n\nexport { getSelectorScore, getAtRuleScore, selectorOrder, atRuleOrder }\n","import { CSSAttribute, Style } from './types'\n\n/**\n * parses the object into css, scoped, blocks\n * @param {Object} obj\n * @param {String} selector\n * @param {String} wrapper\n */\nexport let parse = (obj: CSSAttribute, selector = '{:}') => {\n    let styles: Style[] = []\n\n    for (let key in obj) {\n        let val = obj[key]\n\n        let decl = (val?: string | number) => {\n            // If this isn't an empty rule\n            if (val != undefined) key = key.replace(/[A-Z]/g, '-$&').toLowerCase()\n            // Push the line for this property\n            styles.push({\n                s: selector,\n                p: key,\n                v: val + '',\n                a: []\n            })\n        }\n        if (Array.isArray(val)) {\n            val.map(decl)\n        } else if (key[0] == '@') {\n            // Regular at rule block\n            parse(val as CSSAttribute, key[1] == 'k' ? '' : selector).forEach((style) => {\n                style.a.push(key)\n                styles.push(style)\n            })\n        } else if (typeof val == 'object') {\n            val\n            // Call the parse for this block\n            let newSel = selector\n                ? // Go over the selector and replace the matching multiple selectors if any\n                  selector.replace(/([^,])+/g, (sel) => {\n                      // Return the current selector with the key matching multiple selectors if any\n                      return key.replace(/(^:.*)|([^,])+/g, (k) => {\n                          // If the current `k`(key) has a nested selector replace it\n                          if (/&/.test(k)) return k.replace(/&/g, sel)\n\n                          // If there's a current selector concat it\n                          return sel ? sel + ' ' + k : k\n                      })\n                  })\n                : key\n            styles = styles.concat(parse(val, newSel))\n        } else {\n            decl(val)\n        }\n    }\n\n    // If we have properties apply standard rule composition\n    return styles\n}\n","import { CSSAttribute, Style } from './types'\nimport { atRuleOrder, getAtRuleScore, getSelectorScore, selectorOrder } from '../../core/src/order'\nimport { parse } from './parse'\n\nexport let setup = (\n    selOrder: (string | RegExp)[] = selectorOrder,\n    atOrder: (string | RegExp)[] = atRuleOrder\n) => {\n    // count to generate unique class names.\n    let count: number = 0\n\n    // JavaScript Map like implementation for style sheet.\n    let sheet: Style[] = []\n    let cache: string[] = []\n\n    let render = (styles: CSSAttribute) => {\n        return parse(styles)\n            .map((style) => {\n                //\n                let { s: selector, p: property, v: value, a: atRules } = style\n                let ref = selector + property + value + atRules\n\n                // check the cache for the style\n                let index = cache.indexOf(ref)\n\n                // if the style is not in the cache\n                if (!~index) {\n                    // generate a unique class name. It's base 36 number\n                    let className = (style.c = '_' + (count++).toString(36))\n\n                    // give marks to atRules\n                    let atRuleScore = (style.r = getAtRuleScore(atRules, atOrder))\n                    // give marks to selector\n                    let score = (style.r = getSelectorScore(\n                        selector.replace(/^\\{:\\}/, ''),\n                        selOrder\n                    ))\n\n                    // set the index to last\n                    index = sheet.length\n\n                    // find the index of the style\n                    for (let i = 0, len = sheet.length; i < len; ++i) {\n                        if (\n                            (sheet[i].r as number) > atRuleScore ||\n                            (sheet[i].m as number) > score\n                        ) {\n                            index = i\n                            break\n                        }\n                    }\n\n                    // insert the class name to the selector\n                    style.s = selector.replace(/{:}/g, '.' + className)\n\n                    // update the sheet\n                    sheet.splice(index, 0, style)\n                    cache.splice(index, 0, ref)\n                }\n\n                // return the class name\n                return sheet[index].c as string\n            })\n            .join(' ')\n    }\n\n    return { render, sheet }\n}\n","import { setup } from './setup'\n\nlet { render, sheet } = setup()\n\nexport { render, sheet, setup }\n\nexport type { Style, Context, CSSAttribute } from './types'\n"],"names":["selectorOrder","atRuleOrder","parse","obj","selector","styles","val","key","decl","undefined","replace","toLowerCase","push","s","p","v","a","Array","isArray","map","forEach","style","newSel","sel","k","test","concat","setup","selOrder","atOrder","count","sheet","cache","render","atRules","ref","index","indexOf","className","c","toString","atRuleScore","r","score","atRule","ii","o","i","match","getAtRuleScore","getSelectorScore","length","len","m","splice","join"],"mappings":"AAAA,IAAIA,EAAgB,CAAC,MAAO,MAAO,OAC/BC,EAAc,CAAC,WCORC,EAAQ,SAARA,EAASC,EAAmBC,YAAAA,IAAAA,EAAW,OAC9C,IAAIC,EAAkB,iBAGlB,IAAIC,EAAMH,EAAII,GAEVC,EAAO,SAACF,GAEGG,MAAPH,IAAkBC,EAAMA,EAAIG,QAAQ,SAAU,OAAOC,eAEzDN,EAAOO,KAAK,CACRC,EAAGT,EACHU,EAAGP,EACHQ,EAAGT,EAAM,GACTU,EAAG,MAGX,GAAIC,MAAMC,QAAQZ,GACdA,EAAIa,IAAIX,WACS,KAAVD,EAAI,GAEXL,EAAMI,EAA+B,KAAVC,EAAI,GAAY,GAAKH,GAAUgB,QAAQ,SAACC,GAC/DA,EAAML,EAAEJ,KAAKL,GACbF,EAAOO,KAAKS,aAEK,iBAAPf,EAAiB,CAG/B,IAAIgB,EAASlB,EAEPA,EAASM,QAAQ,WAAY,SAACa,GAE1B,WAAOhB,EAAIG,QAAQ,kBAAmB,SAACc,GAEnC,MAAI,IAAIC,KAAKD,QAAWA,EAAEd,QAAQ,KAAMa,SAGjCA,EAAMA,EAAM,IAAMC,EAAIA,OAGrCjB,EACNF,EAASA,EAAOqB,OAAOxB,EAAMI,EAAKgB,SAElCd,EAAKF,QAxCb,IAAK,IAAIC,KAAOJ,IAAPI,GA6CT,OAAOF,GCpDAsB,EAAQ,SACfC,EACAC,YADAD,IAAAA,EAAgC5B,YAChC6B,IAAAA,EAA+B5B,GAG/B,IAAI6B,EAAgB,EAGhBC,EAAiB,GACjBC,EAAkB,GAqDtB,MAAO,CAAEC,OAnDI,SAAC5B,GACV,OAAOH,EAAMG,GACRc,IAAI,SAACE,GAEF,IAASjB,EAAgDiB,EAAnDR,EAAuCqB,EAAYb,EAAfL,EACtCmB,EAAM/B,EAD+CiB,EAAtCP,EAAsCO,EAAzBN,EACQmB,EAGpCE,EAAQJ,EAAMK,QAAQF,GAG1B,KAAMC,EAAO,CAET,IAAIE,EAAajB,EAAMkB,EAAI,KAAOT,KAASU,SAAS,IAGhDC,EAAepB,EAAMqB,EFpBxB,SAACR,EAAmBL,GACrC,IAAIc,EAAQ,EAMZ,OALAT,EAAQd,QAAQ,SAACwB,EAAQC,GACrBhB,EAAQT,QAAQ,SAAC0B,EAAGC,GACZH,GAAUA,EAAOI,MAAMF,KAAIH,IAAUI,EAAI,IAAMF,EAAK,QAGzDF,EEasCM,CAAef,EAASL,GAEjDc,EAAStB,EAAMqB,EF9BhB,SAACtC,EAAkBwB,GACtC,IAAIe,EAAQ,EAIZ,OAHAf,EAASR,QAAQ,SAAC0B,EAAGC,GACb3C,EAAS4C,MAAMF,KAAIH,GAASI,EAAI,KAEjCJ,EEyBgCO,CACnB9C,EAASM,QAAQ,SAAU,IAC3BkB,GAIJQ,EAAQL,EAAMoB,OAGd,IAAK,IAAIJ,EAAI,EAAGK,EAAMrB,EAAMoB,OAAQJ,EAAIK,IAAOL,EAC3C,GACKhB,EAAMgB,GAAGL,EAAeD,GACxBV,EAAMgB,GAAGM,EAAeV,EAC3B,CACEP,EAAQW,EACR,MAKR1B,EAAMR,EAAIT,EAASM,QAAQ,OAAQ,IAAM4B,GAGzCP,EAAMuB,OAAOlB,EAAO,EAAGf,GACvBW,EAAMsB,OAAOlB,EAAO,EAAGD,GAI3B,OAAOJ,EAAMK,GAAOG,IAEvBgB,KAAK,MAGGxB,MAAAA,MChEGJ,IAAVI,IAAAA,uBAARE"}